# -*- coding: utf-8 -*-
"""Copy of segmentaion_player

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18GN5DiQv7tjZ19Gce18KUC6JVItDQpVM
"""

from google.colab import drive

drive.mount('/content/drive')

"""Import libs"""

# Common
import os
import keras
import numpy as np
import pandas as pd
import tensorflow as tf

# Data
from glob import glob
from tqdm import tqdm
import tensorflow.image as tfi
from tensorflow.keras.utils import load_img, img_to_array

# Data Visualization
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from tensorflow.keras.utils import plot_model
import sys
import skimage.io
# Model
from keras.layers import add
from keras.layers import Input
from keras.layers import Layer
from keras.layers import Conv2D
from keras.layers import multiply
from keras.layers import Dropout
from keras.layers import MaxPool2D
from keras.layers import Concatenate
from keras.layers import Conv2DTranspose
from keras.layers import BatchNormalization
from keras.callbacks import Callback, ModelCheckpoint
from keras.models import Model
# Model Visualization
from tensorflow.keras.utils import plot_model

"""Read Data"""

# read data path
image_paths = '/content/drive/MyDrive/footballer/images*/'

# All Images and thier respective maps
all_images = glob(image_paths + "*.jpg")
all_paths = [path.replace(".jpg",".jpg___fuse.png") for path in all_images]

#check len
print(len(all_images))
print(len(all_paths))
print(len(image_paths))

all_images[2]

all_paths[2]

"""Data Visualization"""

def load_image(path, SIZE=256):
    image = load_img(path)
    image = tfi.resize(image, (SIZE, SIZE))
    image = img_to_array(image)
    image = tf.cast(image, tf.float32)
    image = image/255.
    return image

def load_data(image_paths, label_paths, SIZE=256):
    images, label_maps = np.zeros(shape=(len(image_paths), SIZE, SIZE, 3)), np.zeros(shape=(len(label_paths), SIZE, SIZE, 3))
    for i, (image_path, label_path) in tqdm(enumerate(zip(image_paths, label_paths)), desc="Loading"):
        image, label_map = load_image(image_path, SIZE=SIZE), load_image(label_path, SIZE=SIZE)
        images[i], label_maps[i] = image, label_map
    return images, label_maps

images, label_maps = load_data(all_images, all_paths)

def show_map(image, label_map, alpha_1=1, alpha_2=0.7):
    plt.imshow(image, alpha=alpha_1)
    plt.imshow(label_map, alpha=alpha_2)
    plt.axis('off')

def show_maps(images, label_maps, GRID=[5,6], SIZE=(25,25)):

    # Plot Configuration
    n_rows, n_cols = GRID
    n_images = n_rows * n_cols
    plt.figure(figsize=SIZE)

    # Iterate through the Data
    i=1
    for image, label_map in zip(images, label_maps):

        # Plot Image
        plt.subplot(n_rows, n_cols, i)
        show_map(image, label_map)

        i+=1
        if i>n_images:
            break

    # Final Plot
    plt.show()

show_maps(images, label_maps)

"""Split Data"""

train_images, test_images, train_labels, test_labels = train_test_split(images, label_maps, test_size=0.2, random_state=42)

"""U-Net Encoder"""

def encoder(X, filters, rate=0.2, pooling=True):
    x = BatchNormalization()(X)
    x = Conv2D(filters, kernel_size=3, strides=1, padding='same', activation='relu',
               kernel_initializer='he_normal')(x)
    x = Dropout(rate)(x)
    x = Conv2D(filters, kernel_size=3, strides=1, padding='same', activation='relu',
               kernel_initializer='he_normal')(x)
    if pooling:
        y = MaxPool2D()(x)
        return x, y
    return x

"""U-Net Decoder"""

def decoder(x, skip_x, filters, rate):
    y = Conv2DTranspose(filters, kernel_size=3, strides=2, padding='same', activation='relu',
                        kernel_initializer='he_normal')(BatchNormalization()(x))
    y = encoder(Concatenate()([y, skip_x]), filters, rate, pooling=False)
    return y

"""U-Net Architechture"""

# Input Layer
InputL = Input(shape=(256, 256, 3), name="InputImage")

# Encoder Block
c1, p1 = encoder(InputL, filters=64, rate=0.1)
c2, p2 = encoder(p1, filters=128, rate=0.1)
c3, p3 = encoder(p2, filters=256, rate=0.2)
c4, p4 = encoder(p3, filters=512, rate=0.2)

# Encoding Layer
encodings = encoder(p4, filters=512, rate=0.3, pooling=False)

# Decoder Block
d = decoder(encodings, c4, filters=512, rate=0.2)
d = decoder(d, c3, filters=256, rate=0.2)
d = decoder(d, c2, filters=128, rate=0.1)
d = decoder(d, c1, filters=64, rate=0.1)

# Output
conv_out = Conv2D(3, kernel_size=3, padding='same', activation='sigmoid', name="Segmentator")(d)

# Model
model = Model(InputL, conv_out, name="UNet")
model.summary()

# Compile Model
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

"""Visualization Model"""

plot_model(model, "UNet.png", show_shapes=True)

"""Training Model"""

BATCH_SIZE = 15
SPE = len(images)//BATCH_SIZE

def show_image(image, title=None):
    plt.imshow(image)
    plt.title(title)
    plt.axis('off')

class ShowProgress(Callback):
    def on_epoch_end(self, epoch, logs=None):
        id = np.random.randint(len(images))
        image = images[id]
        mask = label_maps[id]
        pred_mask = self.model(tf.expand_dims(image,axis=0))[0]

        plt.figure(figsize=(10,8))
        plt.subplot(1,3,1)
        show_image(image, title="Original Image")

        plt.subplot(1,3,2)
        show_image(mask, title="Original Mask")

        plt.subplot(1,3,3)
        show_image(pred_mask, title="Predicted Mask")

        plt.tight_layout()
        plt.show()

check_point = [ModelCheckpoint("Segmentation.h5", save_best_only=True),ShowProgress()]

"""UNet Fitting"""

model.fit(
    images, label_maps,
    validation_split=0.1,
    epochs=30,
    batch_size=BATCH_SIZE,
    steps_per_epoch=SPE,
    callbacks=check_point
)

"""Model Evalution"""

prediction = model.predict(test_images)

"""prediction"""

def show_predections(test_images , prediction ,test_labels):

    for i in range(len(test_images)):
        plt.figure(figsize=(10,8))
        plt.subplot(1,3,1)
        show_image(test_images[i], title="Original Image")

        plt.subplot(1,3,2)
        show_image(test_labels[i], title="Original Mask")

        plt.subplot(1,3,3)
        show_image(prediction[i], title="Predicted Mask")

        plt.tight_layout()
        plt.show()

show_predections(test_images , prediction ,test_labels)